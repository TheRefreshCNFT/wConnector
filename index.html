<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>QArt Codes â€“ Access</title>
<style>
    :root {
      --gap: 1rem;
      --pad: .5rem;
      --primary: #2196F3;
      --primary-dark: #1976D2;
      --secondary: #21CBF3;
      --text: #e4e8ff;
      --text-light: #9aa3d9;
      --bg: #050810;
      --card-bg: rgba(7, 12, 30, 0.92);
      --border: rgba(120, 141, 255, 0.35);
      --success: #4CAF50;
      --error: #f44336;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #000; /* app background will show once gate is gone */
      color: var(--text);
      line-height: 1.6;
    }

    /* --- APP AREA (QArt app under overlay) --- */
#appWrapper {
  position: relative;
  min-height: 100vh;
  padding: 24px;
  display: flex;
  justify-content: center;
  align-items: center;
  background:
    radial-gradient(circle at top left, #252b42 0, #050810 55%, #020308 100%);
  overflow: visible;
}
    .qart-container {
      background: var(--card-bg);
      border-radius: 22px;
      box-shadow:
        0 26px 55px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      width: 100%;
      max-width: 720px;
      padding: 28px 26px 26px;
      text-align: left;
      color: var(--text);
      border: 1px solid var(--border);
      backdrop-filter: blur(16px);
    }

    .qart-header {
      margin-bottom: 22px;
      text-align: center;
    }

    .qart-header h1 {
      color: #f5f5ff;
      font-size: 2.1rem;
      margin-bottom: 6px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .subtitle {
      color: #a9b5ff;
      font-size: 0.96rem;
      font-weight: 500;
    }

    .cardano-logo {
      width: 60px;
      height: 60px;
      background: radial-gradient(circle at 30% 20%, #ffc857 0, #ff3366 45%, #5c2cff 100%);
      border-radius: 18px;
      margin: 0 auto 14px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #050814;
      font-weight: 800;
      font-size: 1.05rem;
      box-shadow:
        0 14px 28px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.08);
      text-transform: uppercase;
    }

    .input-container {
      margin-bottom: 12px;
      text-align: left;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #d6ddff;
      font-weight: 600;
      font-size: 0.95rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    textarea {
      width: 100%;
      height: 120px;
      padding: 14px 14px;
      border-radius: 14px;
      font-size: 0.95rem;
      resize: vertical;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, transform 0.08s ease;
      background: rgba(5, 10, 24, 0.9);
      border: 1px solid rgba(120, 141, 255, 0.6);
      color: #eef1ff;
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
    }

    textarea:focus {
      border-color: #ffc857;
      box-shadow:
        0 0 0 1px rgba(255, 200, 87, 0.7),
        0 0 30px rgba(255, 135, 189, 0.25);
      transform: translateY(-1px);
    }

    textarea::placeholder {
      color: rgba(180, 190, 255, 0.5);
    }

    /* Mode row (Code / Image toggle + Add Image button) */
    .mode-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .mode-label {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #cbd3ff;
      font-weight: 600;
    }

    .mode-option {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.9rem;
      color: #d6ddff;
      cursor: pointer;
    }

    .mode-option input[type="radio"] {
      cursor: pointer;
      accent-color: #ff3366;
    }

    .btn-secondary {
      border-radius: 999px;
      border: 1px solid rgba(126, 148, 255, 0.9);
      background: radial-gradient(circle at top left, rgba(5, 10, 24, 0.98), rgba(21, 28, 70, 0.98));
      color: #e4e8ff;
      padding: 7px 16px;
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      box-shadow:
        0 10px 22px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.03);
      transition: all 0.18s ease-out;
      white-space: nowrap;
    }

    .btn-secondary:hover {
      transform: translateY(-1px) scale(1.01);
      box-shadow:
        0 14px 28px rgba(0, 0, 0, 0.8),
        0 0 18px rgba(92, 44, 255, 0.35);
      background: linear-gradient(135deg, #5c2cff, #21cbf3);
      color: #050814;
    }

    .btn-secondary:active {
      transform: translateY(0);
      box-shadow:
        0 8px 18px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.03);
    }

    .image-instructions {
      background: radial-gradient(circle at top left, rgba(41, 52, 120, 0.8), rgba(7, 12, 30, 0.98));
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(112, 139, 255, 0.5);
      box-shadow:
        0 10px 24px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      font-size: 0.86rem;
      color: #dbe2ff;
      margin-bottom: 10px;
    }

    .image-instructions strong {
      color: #ffc857;
    }

    .btn {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      border: none;
      padding: 14px 30px;
      font-size: 1rem;
      font-weight: 700;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.22s ease-out;
      box-shadow:
        0 16px 35px rgba(0,0,0,0.8),
        0 0 0 1px rgba(255,255,255,0.04);
      width: 100%;
      margin-bottom: 22px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .btn:hover {
      transform: translateY(-2px) scale(1.01);
      box-shadow:
        0 20px 40px rgba(0,0,0,0.9),
        0 0 30px rgba(255, 155, 210, 0.25);
      background: linear-gradient(135deg, #ff4b80, #ffd46b);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow:
        0 8px 18px rgba(0,0,0,0.85),
        0 0 0 1px rgba(255,255,255,0.04);
    }

    .qr-container {
      display: none;
      margin-top: 4px;
      padding: 14px 12px 16px;
      border-radius: 18px;
      background: radial-gradient(circle at top, #121727 0, #050814 60%, #020309 100%);
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(126, 148, 255, 0.35);
    }

    #qrcode {
      margin: 0 auto;
      padding: 7px;
      background: #ffffff;
      border-radius: 14px;
      width: 100%;
      height: auto;
      display: block;
      box-shadow:
        0 12px 26px rgba(0,0,0,0.6),
        0 0 0 1px rgba(0,0,0,0.5);
    }

    .download-controls {
      margin-top: 12px;
      text-align: center;
    }

    .download-label {
      font-size: 0.85rem;
      color: #c4ccff;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .download-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
    }

    .dl-btn {
      border: 1px solid rgba(126, 148, 255, 0.8);
      background: rgba(10, 16, 35, 0.9);
      color: #e4e8ff;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.82rem;
      cursor: pointer;
      min-width: 52px;
      transition: background 0.18s ease, color 0.18s ease, transform 0.1s ease, box-shadow 0.18s ease;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .dl-btn:hover {
      background: linear-gradient(135deg, #5c2cff, #21cbf3);
      color: #050814;
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.8);
    }

    .error {
      color: #ff8b94;
      margin: 8px 0 4px;
      font-weight: 500;
      min-height: 24px;
      font-size: 0.9rem;
    }

    .instructions {
      background: radial-gradient(circle at top left, rgba(41, 52, 120, 0.85), rgba(7, 12, 30, 0.98));
      padding: 16px 14px 14px;
      border-radius: 16px;
      margin-top: 20px;
      text-align: left;
      border: 1px solid rgba(112, 139, 255, 0.45);
      box-shadow:
        0 16px 34px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.02);
    }

    .instructions h3 {
      color: #f0f2ff;
      margin-bottom: 8px;
      font-size: 0.98rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .instructions ul {
      padding-left: 18px;
      color: #cbd3ff;
      font-size: 0.9rem;
    }

    .instructions li {
      margin-bottom: 6px;
    }

    @media (max-width: 480px) {
      #appWrapper {
        padding: 16px;
        align-items: flex-start;
      }

      .qart-container {
        padding: 22px 18px 18px;
        max-width: 100%;
      }
      
      .qart-header h1 {
        font-size: 1.8rem;
      }
      
      .btn {
        padding: 12px 22px;
      }

      .download-buttons {
        gap: 6px;
      }

      .dl-btn {
        font-size: 0.78rem;
        padding: 5px 9px;
      }

      textarea {
        font-size: 0.9rem;
      }

      .mode-row {
        align-items: flex-start;
      }
    }

    /* --- Screenshot overlay for mobile screenshot flow --- */
    #screenshotOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.94);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 20;
      flex-direction: column;
      gap: 1rem;
    }

    #screenshotOverlay img {
      max-width: 100%;
      max-height: 80vh;
      border-radius: 16px;
      background: #fff;
      box-shadow: 0 20px 60px rgba(0,0,0,0.9);
    }

    #screenshotClose {
      position: absolute;
      top: 1rem;
      right: 1rem;
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      background: rgba(0,0,0,0.7);
      color: #fff;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
    }

    #screenshotHint {
      font-size: 0.85rem;
      color: #d5ddff;
      text-align: center;
      max-width: 320px;
    }

    .hidden {
      display: none !important;
    }

    /* --- WALLET GATE OVERLAY --- */
    #gateOverlay {
      position: fixed;
      inset: 0;
      background: var(--bg);
      z-index: 10;
      display: flex;
      flex-direction: column;
    }

    header {
      position: relative;
      background: transparent;
      color: white;
      text-align: center;
      padding: 2rem var(--pad) 1.5rem;
      box-shadow: none;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    #description {
      font-size: 1.2rem;
      opacity: 0.9;
      margin-bottom: 1.5rem;
    }

    #instructions {
      font-size: 1rem;
      margin: 1rem 0;
    }

    #walletStatus {
      background: rgba(255,255,255,0.15);
      border-radius: 50px;
      padding: 0.5rem 1.5rem;
      display: inline-block;
      margin-top: 1rem;
      font-weight: 500;
      backdrop-filter: blur(5px);
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      padding: 0 var(--pad);
    }

    .card {
      background: var(--card-bg);
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.05);
      padding: 2rem;
      margin: 2rem auto;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1rem;
    }

    button {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    #connectBtn {
      background: white;
      color: var(--primary);
    }

    #connectBtn:hover {
      background: #f5f5f5;
      transform: translateY(-2px);
    }

    #connectBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    select, input {
      padding: 0.8rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 1rem;
      width: 100%;
    }

    select {
      flex: 1;
      background: white;
    }

    .access-message {
      margin-top: 1rem;
      font-size: 1rem;
      color: var(--text-light);
    }

    .access-message strong {
      color: var(--success);
    }

    .access-message.error {
      color: var(--error);
    }

    .access-message a {
      color: var(--primary-dark);
      text-decoration: underline;
    }

    /* --- Refreshed wallet gate look --- */

    /* Gate background â€“ dark, subtle gradient */
    #gateOverlay {
      background: radial-gradient(circle at top left, #202738 0, #050810 55%, #020308 100%);
      color: #e4e8ff;
    }

    /* Layout inside header */
    header .container {
      max-width: 860px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    /* Logo in top-left corner */
    .brand-logo {
      position: absolute;
      top: 0.75rem;
      left: 0.75rem;
      width: 52px;
      height: auto;
      padding: 0.25rem;
      background: rgba(5, 8, 16, 0.9);
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.55);
    }

    /* Titles + text */
    header h1 {
      font-size: 2.1rem;
      letter-spacing: 0.04em;
    }

    #description {
      font-size: 1rem;
      opacity: 0.9;
    }

    #instructions {
      font-size: 0.95rem;
      color: #a9b5ff;
    }

    /* Card: glassy panel */
    .card {
      background: rgba(5, 10, 24, 0.9);
      border-radius: 18px;
      border: 1px solid rgba(120, 141, 255, 0.25);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      color: #e4e8ff;
      backdrop-filter: blur(10px);
    }

    /* Wallet row */
    .row {
      margin-top: 0.5rem;
    }

    select,
    #connectBtn {
      border-radius: 999px;
    }

    /* Wallet dropdown */
    select {
      background: rgba(3, 7, 20, 0.9);
      border: 1px solid rgba(96, 125, 255, 0.6);
      color: #e4e8ff;
    }

    /* Connect button â€“ pill, gradient */
    #connectBtn {
      background: linear-gradient(135deg, #ff3366, #ffc857);
      color: #050814;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
    }

    #connectBtn:hover {
      background: linear-gradient(135deg, #ff4b80, #ffd46b);
      transform: translateY(-1px) scale(1.01);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.7);
    }

    /* Status pill */
    #walletStatus {
      background: rgba(9, 16, 40, 0.9);
      border-radius: 999px;
      border: 1px solid rgba(106, 255, 183, 0.4);
      color: #a7ffcb;
    }

    /* Access message */
    .access-message {
      color: #b7c3ff;
    }

    .access-message.error {
      color: #ff8b94;
    }

    .access-message a {
      color: #ffc857;
    }

    /* Mobile tweaks for header/card */
    @media (max-width: 600px) {
      header .container {
        padding-top: 1.5rem;
      }

      header h1 {
        font-size: 1.9rem;
      }

      .card {
        margin-top: 1.5rem;
        padding: 1.5rem;
      }
    }

    @media(max-width: 600px){
      .row {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>

  <!-- APP AREA (hidden until gate passes) -->
  <div id="appWrapper" class="hidden">
    <div class="qart-container">
      <header class="qart-header">
        <div class="cardano-logo">ADA</div>
        <h1>QArt Codes</h1>
        <p class="subtitle">For Cardano Addresses</p>
      </header>
      
      <div class="input-container">
        <label for="cardanoAddress">Enter Cardano Address:</label>
        <textarea 
          id="cardanoAddress" 
          placeholder="Enter Your Cardano Address"
          autocomplete="off"
        ></textarea>
      </div>

      <!-- Mode selection row: Code / Image -->
      <div class="mode-row">
        <span class="mode-label">Style</span>
        <label class="mode-option">
          <input type="radio" name="qartMode" id="modeCode" value="code" checked>
          Code
        </label>
        <label class="mode-option">
          <input type="radio" name="qartMode" id="modeImage" value="image">
          Image
        </label>
        <button type="button" id="addImageBtn" class="btn-secondary" style="display:none;">Add Image</button>
      </div>
      <div id="imageInstructions" class="image-instructions hidden">
        Click <strong>Add Image</strong> to add one of your choice to the QArt code.
        Use a square image for best results. Minimum size <strong>512 Ã— 512</strong>.
        Click Generate <strong>QART CODE</strong> after you upload the image.
      </div>
      <input type="file" id="imageFile" accept="image/*" style="display:none;">
      
      <div class="error" id="errorMsg"></div>
      
      <button class="btn" id="generateBtn">Generate QArt Code</button>
      
      <div class="qr-container" id="qrContainer">
        <canvas id="qrcode"></canvas>

        <!-- Download controls -->
        <div id="downloadControls" class="download-controls" style="display:none;">
          <p class="download-label">Download PNG:</p>
          <div class="download-buttons">
            <button type="button" class="dl-btn" data-size="1024" data-label="1k">1K</button>
            <button type="button" class="dl-btn" data-size="2048" data-label="2k">2K</button>
            <button type="button" class="dl-btn" data-size="4096" data-label="4k">4K</button>
            <button type="button" class="dl-btn" data-size="8192" data-label="8k">8K</button>
            <button type="button" class="dl-btn" data-size="16384" data-label="16k">16K</button>
            <!-- New screenshot view button -->
            <button type="button" class="dl-btn" id="screenshotBtn">Screenshot View</button>
          </div>
        </div>
      </div>
      
      <div class="instructions">
        <h3>How to use:</h3>
        <ul>
          <li>Current address captured, paste over to change</li>
          <li>Click "Generate QArt Code" to create a QR code</li>
          <li>Scan the QR code with any Cardano wallet</li>
          <li>Download and save to reuse, send, or frame</li>
          <li>On mobile explorers: use <strong>Screenshot View</strong> and screenshot to save</li>
          <li>Cardano addresses start with "addr1"</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Full-screen screenshot overlay -->
  <div id="screenshotOverlay" class="hidden">
    <button id="screenshotClose">âœ• Close</button>
    <img id="screenshotImage" alt="QArt Screenshot View">
    <p id="screenshotHint">
      On mobile wallet explorers, tap and hold to save the image, or take a screenshot to keep your QArt code.
    </p>
  </div>

  <!-- WALLET GATE OVERLAY -->
  <div id="gateOverlay">
    <!-- Logo in top-left corner -->
    <img src="RF5.png" alt="Fre5h Logo" class="brand-logo">

    <header>
      <div class="container">
        <h1>QArt Codes</h1>

        <p id="description">Exclusive access for peeps who get Fre5h! ðŸ”„</p>
        <p id="instructions">Connect a Cardano wallet that holds at least 10 OG The Refresh.</p>

        <div class="row">
          <select id="walletSelect">
            <option value="">Select Walletâ€¦</option>
            <!-- Wallets will be populated dynamically -->
          </select>
          <button id="connectBtn" disabled>Connect Wallet</button>
        </div>

        <div id="walletStatus" class="hidden"></div>
      </div>
    </header>

    <div class="container">
      <div class="card">
        <h2>Access Gate</h2>
        <p>
          Fre5h Fence Activated!!
          QArt Codes access requires the connected wallet to hold 10 OG The Refresh.
        </p>
        <p id="accessMessage" class="access-message"></p>
      </div>
    </div>
  </div>

  <!-- QRious library for real QR code generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

  <!-- QArt APP SCRIPT -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const addressInput      = document.getElementById('cardanoAddress');
      const generateBtn       = document.getElementById('generateBtn');
      const qrContainer       = document.getElementById('qrContainer');
      const qrCanvas          = document.getElementById('qrcode');
      const errorMsg          = document.getElementById('errorMsg');
      const downloadControls  = document.getElementById('downloadControls');
      const ctx               = qrCanvas.getContext('2d');

      const modeCodeRadio     = document.getElementById('modeCode');
      const modeImageRadio    = document.getElementById('modeImage');
      const addImageBtn       = document.getElementById('addImageBtn');
      const imageInstructions = document.getElementById('imageInstructions');
      const imageInput        = document.getElementById('imageFile');

      const screenshotBtn     = document.getElementById('screenshotBtn');
      const screenshotOverlay = document.getElementById('screenshotOverlay');
      const screenshotImage   = document.getElementById('screenshotImage');
      const screenshotClose   = document.getElementById('screenshotClose');

      // Offscreen canvases for raw QR and art / image pattern
      const qrRawCanvas  = document.createElement('canvas');
      const qrRawCtx     = qrRawCanvas.getContext('2d');
      const artCanvas    = document.createElement('canvas');
      const artCtx       = artCanvas.getContext('2d');

      // Remember last generated state for exports
      let lastAddress = '';
      let lastSeed    = null;

      // Mode + uploaded image
      let currentMode    = 'code';  // 'code' or 'image'
      let uploadedImage  = null;

      // Mode switching
      function updateModeUI() {
        if (currentMode === 'image') {
          addImageBtn.style.display = 'inline-flex';
          imageInstructions.classList.remove('hidden');
        } else {
          addImageBtn.style.display = 'none';
          imageInstructions.classList.add('hidden');
        }
      }

      modeCodeRadio.addEventListener('change', () => {
        if (modeCodeRadio.checked) {
          currentMode = 'code';
          updateModeUI();
        }
      });

      modeImageRadio.addEventListener('change', () => {
        if (modeImageRadio.checked) {
          currentMode = 'image';
          updateModeUI();
        }
      });

      addImageBtn.addEventListener('click', () => {
        imageInput.click();
      });

      imageInput.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(ev) {
          const img = new Image();
          img.onload = function() {
            uploadedImage = img;
          };
          img.onerror = function() {
            alert('Unable to load that image. Please try a different file.');
          };
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      });

      // Basic Cardano address validation
      function isValidCardanoAddress(address) {
        return address.startsWith('addr1') && address.length >= 50 && address.length <= 110;
      }

      // Consistent large internal resolution for crispness on-screen
      function computeCanvasSize() {
        const dpr = window.devicePixelRatio || 1;
        const cssSize = 512;          // logical base size; canvas stretches to card width
        return Math.round(cssSize * dpr);
      }

      // Seeded RNG so we can reproduce the same art pattern at any resolution
      function createRNG(seed) {
        let s = seed % 2147483647;
        if (s <= 0) s += 2147483646;
        return function() {
          s = s * 16807 % 2147483647;
          return (s - 1) / 2147483646;
        };
      }

      // --- Color helpers (kept, but no longer used for stylizing the art) ---
      function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
          h = 0; s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        return [h, s, l];
      }

      function hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          }
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }

      // --- Complex random art pattern each time (now using seeded RNG) ---
      function drawArtPattern(context, size, rng) {
        context.clearRect(0, 0, size, size);

        // Palette: fully random hues, deterministic via rng
        const palette = [
          { h: rng() * 359, s: 0.90, l: 0.80 },
          { h: rng() * 359, s: 0.95, l: 0.62 },
          { h: rng() * 359, s: 0.95, l: 0.64 },
          { h: rng() * 359, s: 0.95, l: 0.55 },
          { h: rng() * 359, s: 0.50, l: 0.50 }
        ];
        function pickColor() {
          const c = palette[Math.floor(rng() * palette.length)];
          return `hsla(${c.h}, ${c.s * 100}%, ${c.l * 100}%, 0.4)`;
        }

        // 1) Base gradient
        const cx = size * (0.3 + rng() * 0.4);
        const cy = size * (0.3 + rng() * 0.4);
        const grad = context.createRadialGradient(
          cx, cy, size * 0.05,
          cx, cy, size * 0.9
        );
        grad.addColorStop(0.0, '#000000');
        grad.addColorStop(0.35, '#000000');
        grad.addColorStop(0.7, '#000000');
        grad.addColorStop(1.0, '#000000');
        context.fillStyle = grad;
        context.fillRect(0, 0, size, size);

        // 2) Cloudy blobs (currently disabled)
        const blobCount = 0;
        for (let i = 0; i < blobCount; i++) {
          const x = rng() * size;
          const y = rng() * size;
          const r = size * (0.06 + rng() * 0.20);
          const blobGrad = context.createRadialGradient(x, y, 0, x, y, r);

          const baseHue = 185 + rng() * 120;
          const col1 = `hsla(${baseHue}, 95%, 70%, 0.7)`;
          const col2 = `hsla(${baseHue}, 85%, 55%, 0.5)`;
          const col3 = 'rgba(115,50,0,.7)';

          blobGrad.addColorStop(0.0, col1);
          blobGrad.addColorStop(0.4, col2);
          blobGrad.addColorStop(1.0, col3);

          context.globalAlpha = 0.9;
          context.fillStyle = blobGrad;
          context.beginPath();
          context.arc(x, y, r, 0, Math.PI * 2);
          context.fill();
        }
        context.globalAlpha = 1;

        // 3) Flow-field streaks
        const strokeLayers = 1;
        for (let layer = 0; layer < strokeLayers; layer++) {
          const layerColor = pickColor();
          const steps = 1400;
          const stepLen = size * 0.08;
          const thickness = size * (0.002 + layer * 0.001);

          context.lineWidth = thickness;
          context.strokeStyle = layerColor;
          context.globalAlpha = 0.9 + layer * 0.15;
        
          // Make streaks smooth with rounded ends & corners
          context.lineCap = 'round';
          context.lineJoin = 'round';
          context.miterLimit = 2; // optional, extra safety against spikes

          const seed1 = rng() * 20;
          const seed2 = rng() * 20;

          for (let i = 0; i < steps; i++) {
            let x = rng() * size;
            let y = rng() * size;

            const segments = 6 + Math.floor(rng() * 5);
            const pts = [{ x, y }];

            // Collect the raw polyline points
            for (let s = 0; s < segments; s++) {
              const nx = x / size;
              const ny = y / size;

              const angle =
                Math.sin(nx * 6 + seed1) * Math.PI * 0.7 +
                Math.cos(ny * 5 + seed2) * Math.PI * 0.6 +
                (nx - 0.5) * Math.PI * 0.4 -
                (ny - 0.5) * Math.PI * 0.4;

              x += Math.cos(angle) * stepLen;
              y += Math.sin(angle) * stepLen;

              if (x < -size * 0.05 || x > size * 1.05 || y < -size * 0.05 || y > size * 1.05) {
                break;
              }
              pts.push({ x, y });
            }

            if (pts.length < 2) continue;

            // Draw a smoothed curve through the points
            context.beginPath();
            context.moveTo(pts[0].x, pts[0].y);

            if (pts.length === 2) {
              // Just a straight segment
              context.lineTo(pts[1].x, pts[1].y);
            } else {
              // Midpoint-based quadratic smoothing
              for (let j = 1; j < pts.length - 1; j++) {
                const p0 = pts[j];
                const p1 = pts[j + 1];
                const cx = (p0.x + p1.x) / 2;
                const cy = (p0.y + p1.y) / 2;
                context.quadraticCurveTo(p0.x, p0.y, cx, cy);
              }
              // Ensure we land on the very last point
              const last = pts[pts.length - 1];
              context.lineTo(last.x, last.y);
            }

            context.stroke();
          }
        }
        context.globalAlpha = 1;

        // 4) Tiny sparkles (disabled)
        const sparkCount = 0;
        context.fillStyle = 'rgba(255,255,255,0.9)';
        for (let i = 0; i < sparkCount; i++) {
          const sx = rng() * size;
          const sy = rng() * size;
          const r = size * (rng() < 0.3 ? 0.0045 : 0.0025);
          context.beginPath();
          context.arc(sx, sy, r, 0, Math.PI * 2);
          context.fill();
        }
      }

      // Draw uploaded image as pattern (fills the square, preserving aspect ratio)
      function drawImagePattern(context, size, img) {
        context.clearRect(0, 0, size, size);
        const iw = img.width;
        const ih = img.height;
        if (!iw || !ih) return;

        const scale = Math.max(size / iw, size / ih);
        const drawW = iw * scale;
        const drawH = ih * scale;
        const dx = (size - drawW) / 2;
        const dy = (size - drawH) / 2;
        context.drawImage(img, dx, dy, drawW, drawH);
      }

      // Core renderer used for both on-screen and export
      function renderQArtToCanvas(targetCanvas, size, text, seed) {
        const targetCtx = targetCanvas.getContext('2d');

        // Set up canvases
        targetCanvas.width = size;
        targetCanvas.height = size;
        qrRawCanvas.width = size;
        qrRawCanvas.height = size;
        artCanvas.width = size;
        artCanvas.height = size;

        const rng = createRNG(seed);

        // Draw art pattern or uploaded image into artCanvas
        if (currentMode === 'image' && uploadedImage) {
          drawImagePattern(artCtx, size, uploadedImage);
        } else {
          drawArtPattern(artCtx, size, rng);
        }

        // Generate raw QR (black/white) into qrRawCanvas
        new QRious({
          element: qrRawCanvas,
          value: text,
          size: size,
          level: 'H',
          background: '#ffffff',
          foreground: '#000000'
        });

        const qrImageData  = qrRawCtx.getImageData(0, 0, size, size);
        const qrData       = qrImageData.data;
        const artImageData = artCtx.getImageData(0, 0, size, size);
        const artData      = artImageData.data;
        const outImageData = targetCtx.createImageData(size, size);
        const outData      = outImageData.data;

        // Mix QR with art/image colors
        for (let i = 0; i < qrData.length; i += 4) {
          const r = qrData[i];
          const g = qrData[i + 1];
          const b = qrData[i + 2];

          if (r < 128 && g < 128 && b < 128) {
            // QR "black" modules: use underlying art/image pixel as-is
            const ar = artData[i];
            const ag = artData[i + 1];
            const ab = artData[i + 2];

            outData[i]     = ar;
            outData[i + 1] = ag;
            outData[i + 2] = ab;
            outData[i + 3] = 255;
          } else {
            // QR "white" modules stay pure white
            outData[i]     = 255;
            outData[i + 1] = 255;
            outData[i + 2] = 255;
            outData[i + 3] = 255;
          }
        }
        targetCtx.putImageData(outImageData, 0, 0);
      }

      function generateQRCode(text) {
        const size = computeCanvasSize();
        // New seed for this image; stored for exports
        lastSeed = Math.floor(Math.random() * 1e9);
        lastAddress = text;
        renderQArtToCanvas(qrCanvas, size, text, lastSeed);
      }

      function downloadAtSize(pixelSize, label) {
        if (!lastAddress || lastSeed === null) {
          alert('Generate a QArt Code first.');
          return;
        }

        const exportCanvas = document.createElement('canvas');
        renderQArtToCanvas(exportCanvas, pixelSize, lastAddress, lastSeed);

        const link = document.createElement('a');
        const safeAddr = lastAddress.slice(0, 12).replace(/[^a-zA-Z0-9]+/g, '_');
        link.download = `qart_${safeAddr}_${label}.png`;
        link.href = exportCanvas.toDataURL('image/png');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      generateBtn.addEventListener('click', function() {
        const address = addressInput.value.trim();
        errorMsg.textContent = '';
        
        if (!address) {
          errorMsg.textContent = 'Please enter a Cardano address';
          return;
        }
        
        if (!isValidCardanoAddress(address)) {
          errorMsg.textContent = 'Please enter a valid Cardano address starting with "addr1"';
          return;
        }

        if (currentMode === 'image' && !uploadedImage) {
          errorMsg.textContent = 'Please click "Add Image" and choose an image before generating.';
          return;
        }
        
        generateQRCode(address);
        qrContainer.style.display = 'block';
        downloadControls.style.display = 'block';
        // no auto-scroll â€“ user can scroll up/down freely
      });

      // Wire up download buttons
      const dlButtons = downloadControls.querySelectorAll('.dl-btn');
      dlButtons.forEach(btn => {
        const sizeAttr = btn.getAttribute('data-size');
        if (sizeAttr) {
          btn.addEventListener('click', function() {
            const size  = parseInt(btn.getAttribute('data-size'), 10);
            const label = btn.getAttribute('data-label') || (size / 1024 + 'k');
            downloadAtSize(size, label);
          });
        }
      });

      // Screenshot View button (full-screen overlay, no "download" attribute)
      screenshotBtn.addEventListener('click', () => {
        if (!lastAddress || lastSeed === null) {
          alert('Generate a QArt Code first.');
          return;
        }
        // Use the currently rendered on-screen canvas
        const dataUrl = qrCanvas.toDataURL('image/png');
        screenshotImage.src = dataUrl;
        screenshotOverlay.classList.remove('hidden');
      });

      screenshotClose.addEventListener('click', () => {
        screenshotOverlay.classList.add('hidden');
      });

      // Optional: tap outside image to close
      screenshotOverlay.addEventListener('click', (e) => {
        if (e.target === screenshotOverlay) {
          screenshotOverlay.classList.add('hidden');
        }
      });
      
      // Sample address (will be overwritten by wallet address once connected)
      addressInput.value = 'Enter Your Cardano Address';

      // Initialize mode UI
      updateModeUI();
    });
  </script>

  <!-- Wallet connector gate (unchanged) -->
<script type="module">
  import { BrowserWallet } from 'https://esm.sh/@meshsdk/core@1.9.0-beta.62?bundle';

  const sel           = document.getElementById('walletSelect');
  const btn           = document.getElementById('connectBtn');
  const walletStatus  = document.getElementById('walletStatus');
  const accessMessage = document.getElementById('accessMessage');
  const gateOverlay   = document.getElementById('gateOverlay');
  const appWrapper    = document.getElementById('appWrapper');

  // Fixed policy ID to check (no user prompt)
  const POLICY_ID = 'adc5716393953403109c335e68c0384238fd19653e960e03afa1fb1f';

  let meshWallet, userAddress;

async function detect() {
  try {
    const wallets = await BrowserWallet.getInstalledWallets();

    if (!wallets.length) {
      sel.innerHTML = '<option>(no wallets detected)</option>';
      return;
    }

    // Prefer "mesh" if present â€“ but now use .id
    wallets.sort((a, b) =>
      a.id === 'mesh' ? -1 : b.id === 'mesh' ? 1 : 0
    );

    // IMPORTANT: value = wallet.id, label = wallet.name
    sel.innerHTML = wallets
      .map(
        (w) =>
          `<option value="${w.id}">${w.name}</option>`
      )
      .join('');

    // Default to the first wallet's id
    sel.value = wallets[0].id;
    btn.disabled = false;
  } catch (err) {
    console.error('Wallet detection failed:', err);
    sel.innerHTML = '<option>(wallet detection failed)</option>';
  }
}


  async function checkPolicyAssets() {
    if (!meshWallet) return;

    // Show "Checking Wallet" while the scan is running
    walletStatus.classList.remove('hidden');
    walletStatus.textContent = 'Checking Walletâ€¦';
    accessMessage.textContent = '';
    accessMessage.classList.remove('error');

    try {
      // Mesh aggregates across all addresses in the wallet
      const assets = await meshWallet.getAssets();
      console.log('[QArt] Assets:', assets);

      let count = 0;
      for (const asset of assets) {
        if (asset.policyId === POLICY_ID) {
          count++;
        }
      }

      if (count >= 10) {
        walletStatus.textContent =
          `Found ${count} asset${count === 1 ? '' : 's'} from the policy in this wallet. âœ… Access granted.`;
        accessMessage.innerHTML = '<strong>Access granted. Loading QArt Code Genâ€¦</strong>';

        // SHOW APP, HIDE GATE
        appWrapper.classList.remove('hidden');
        gateOverlay.classList.add('hidden');
      } else {
        walletStatus.textContent =
          `Found ${count} asset${count === 1 ? '' : 's'} from the policy in this wallet.`;
        accessMessage.classList.add('error');
        accessMessage.innerHTML =
          `<a href="https://www.jpg.store/collection/therefresh" target="_blank" rel="noopener noreferrer">
             Purchase Assets
           </a>`;
      }
    } catch (err) {
      console.error(err);
      walletStatus.textContent = 'Error checking wallet assets.';
      accessMessage.classList.add('error');
      accessMessage.textContent = 'An error occurred while checking your wallet. Please try again.';
    }
  }

async function connect() {
  const walletId = sel.value; // this is e.g. "vespr", "nami", "eternl", etc.
  if (!walletId) {
    alert('Select a wallet');
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Connectingâ€¦';

  try {
    // This should trigger the walletâ€™s normal permission / unlock UI
    meshWallet = await BrowserWallet.enable(walletId);
    userAddress = await meshWallet.getChangeAddress();

    btn.textContent = `Connected: ${walletId}`;
    sel.disabled = true;
    console.log('Connected address:', userAddress);

    const addrField = document.getElementById('cardanoAddress');
    if (addrField && typeof userAddress === 'string') {
      addrField.value = userAddress;
    }

    // Run the policy check in the background right after connection
    checkPolicyAssets();
  } catch (e) {
    console.error('Wallet connection failed:', e);

    let humanMsg =
      'Connection failed.\n\n' +
      'â€¢ If your wallet uses a PIN/password, open the wallet extension/app and unlock it first.\n' +
      'â€¢ Then come back here and press "Connect Wallet" again.';

    if (e && e.message) {
      humanMsg = `Connection failed: ${e.message}\n\n` + humanMsg;
    }

    alert(humanMsg);
    btn.textContent = 'Connect Wallet';
    btn.disabled = false;
  }
}


  document.addEventListener('DOMContentLoaded', detect);
  btn.addEventListener('click', connect);
</script>

</body>
</html>
